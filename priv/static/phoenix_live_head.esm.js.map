{
  "version": 3,
  "sources": ["../../assets/js/phoenix_live_head/index.ts"],
  "sourcesContent": ["module PhxLiveHead {\n  // TYPES\n  type action = \"s\" | \"a\" | \"x\" |\"b\" |\"r\" | \"t\" | \"i\" | \"d\";\n  type attr = string;\n  type value = string;\n  type query = string;\n  type change = [action, attr, value]\n  type detail = {\"c\": [[query, change[]]]}\n  type state = { [key: attr]: string | null}\n\n  // CONSTANTS\n  export const NAMESPACE: string = 'plh';\n  const ALL_ATTR: string = '*';\n  const CLASS_ATTR: string = \"class\";\n  const ATTR: { [key: string]: string } = { \"c\": CLASS_ATTR, \"h\": \"href\" }\n  const QUERY: { [key: string]: string } = { \"f\": \"link[rel*='icon']\" }\n\n  // HELPERS\n  function camelToKebabCase(s: string): string { return s.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase(); }\n  function stateKey(key: string, el: HTMLElement): string { return `${NAMESPACE}:${el.dataset['id']}-${key}`; }\n  function randId(): string {\n  return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n}\n  function attrObject(el: HTMLElement): state {\n    return Array.from(el.attributes)\n      .filter(a => a.specified)\n      .map(a => ({[a.nodeName]: a.nodeValue}))\n      .reduce((prev, curr) => Object.assign(prev || {}, curr))\n  }\n\n  function isStateBackupped(el: HTMLElement, attr: string, key: string): boolean {\n    const saved = getState(el, key)\n    if(saved !== undefined && attr === ALL_ATTR){ return true}\n    if(saved !== undefined && attr !== ALL_ATTR){ return saved[attr] !== undefined }\n\n    return false\n  }\n\n  function getState(el: HTMLElement, key: string): state | undefined {\n    const value = sessionStorage.getItem(stateKey(key, el)) || null\n    return value !== (undefined  || null) ? JSON.parse(value) : undefined\n  }\n\n  function saveState(el: HTMLElement, key: string, value: object): void {\n    return sessionStorage.setItem(stateKey(key, el), JSON.stringify(value))\n  }\n\n\n  function backupState(el: HTMLElement, attr: string, key: string): void {\n    const attrs = attrObject(el)\n\n    if(attr !== ALL_ATTR){ return saveState(el, key, {[attr]: attrs[attr]}); }\n\n    saveState(el, key, attrs);\n  }\n\n  function restoreState(el: HTMLElement, attr: string, key: string): void {\n    const state = getState(el, key)\n\n    if(state === undefined) {\n      console.warn(`No state backup found for key ${stateKey(key, el)}`)\n    } else {\n      if(attr !== ALL_ATTR){ return restoreAttrState(el, attr, key) }\n\n      for(const attr of Object.keys(state)) {\n        restoreAttrState(el, attr, key)\n      }}\n  }\n\n  function restoreAttrState(el: HTMLElement, attr: attr, key: string): void {\n    const state = getState(el, key)\n\n    if(state === undefined) {\n      console.warn(`No state backup found for key ${stateKey(key, el)}`)\n    } else {\n      const value = state[attr]\n\n      if (value !== (undefined || null)) {\n        attr === CLASS_ATTR ? el.className = value : el.setAttribute(attr, value);\n      }\n    }\n  }\n\n  function setDynamicAttributes(el: HTMLElement, replacements: {[key: string]: string}){\n    for(const [dynKey, dynTempl] of Object.entries(el.dataset).filter(([key, _]) => key.startsWith('dynamic'))) {\n      const attr = camelToKebabCase(dynKey.substring(\"dynamic\".length))\n      if(dynTempl === undefined){return;}\n      if(Object.keys(replacements).some(replacement => dynTempl?.includes(`{${replacement}}`))){\n        const newValue: string = dynTempl?.replace(\n          /{(\\w+)}/g,\n          (placeholderWithDelimiters, placeholderWithoutDelimiters) =>\n            replacements.hasOwnProperty(placeholderWithoutDelimiters) ?\n              replacements[placeholderWithoutDelimiters] : sessionStorage.getItem(stateKey('dyn-' + placeholderWithoutDelimiters, el)) || `[!value for ${placeholderWithDelimiters} not found!]`\n        );\n\n        el.setAttribute(attr, newValue)\n      }\n    }\n  }\n\n  function applyToElement(el: HTMLElement, changes: change[]) {\n    let replacements = {}\n\n    changes.forEach(function (change: change) {\n      const [action, attr_input, value] = change;\n      const attr = ATTR[attr_input] || attr_input\n\n      // we collect all replacements so we can set them all at once\n      // as there might be multiple in a single attribute\n      if (action === \"d\") {\n        replacements = {[attr]: value, ...replacements};\n        sessionStorage.setItem(stateKey('dyn-' + attr, el), value);\n        return;\n        // the replacement takes place before any other action\n      } else if (Object.keys(replacements).length > 0) {\n        setDynamicAttributes(el, replacements);\n        replacements = []\n      }\n\n      if (attr === CLASS_ATTR) {\n        switch (action) {\n          case \"s\": el.className = value; break;\n          case \"a\": el.classList.add(value); break;\n          case \"x\": el.classList.remove(value); break;\n          case \"t\": el.classList.toggle(value); break;\n          case \"b\": backupState(el, attr_input, value); break;\n          case \"r\": restoreState(el, attr, value); break;\n          case \"i\": restoreState(el, attr, 'orig'); break;\n          default: null\n        }\n      } else {\n        switch (action) {\n          case \"s\": el.setAttribute(attr, value); break;\n          case \"x\": el.removeAttribute(attr); break;\n          case \"b\": backupState(el, attr_input, value); break;\n          case \"r\": restoreState(el, attr, value); break;\n          case \"i\": restoreState(el, attr, 'orig'); break;\n          default: null\n        }\n      }\n    }\n    );\n\n    // execute remaining replacements when there was no\n    // subsequent action\n    if (Object.keys(replacements).length > 0) {\n        setDynamicAttributes(el, replacements);\n    }\n\n  };\n\n  export function main(event: Event): void {\n    const detail: detail = (event as CustomEvent).detail;\n    // the list of [query, changes] is sent in reverse, due to prepending items\n    for (const [query_input, changes_input] of detail.c.reverse()) {\n      const query = QUERY[query_input] || query_input\n      const elements = document.querySelectorAll(query);\n      // the list of changes is sent in reverse, due to prepending items\n      const changes = changes_input.reverse()\n\n      elements.forEach(el => {\n        const tel = el as HTMLElement;\n        if(!tel.dataset['id']){tel.dataset['id'] = randId()}\n        if (!isStateBackupped(tel, ALL_ATTR, 'orig')) { backupState(tel, ALL_ATTR, 'orig') }\n\n        applyToElement(tel, changes)\n      })\n    }\n  }\n}\n\n// clear session keys of Phoenix Live Head\nObject.keys(sessionStorage).forEach(key => key.startsWith(PhxLiveHead.NAMESPACE) && sessionStorage.removeItem(key))\n\nwindow.addEventListener(\"phx:hd\", (event: Event) => {\n  PhxLiveHead.main(event);\n});\n"],
  "mappings": "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",
  "names": []
}
